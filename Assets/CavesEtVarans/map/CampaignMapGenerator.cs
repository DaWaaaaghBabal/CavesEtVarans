using CavesEtVarans.battlefield;
using CavesEtVarans.utils;
using System.Collections.Generic;
using System;
using CavesEtVarans.graphics;
using UnityEngine;

namespace CavesEtVarans.map {
    class CampaignMapGenerator : IMapGenerator {
        /* The campaign map is generated by a pen following a spiral pattern from a central point.
         * The pen places tiles while walking around the tiles he already has laid.
         * The algorithm follows this algorithm :
         * - Place a tile where you stand, assign it to the current region
         * - If the position behind on the left is free, place a tile on it and assign it to the current region
         * - If the current region is full, switch to the next
         * - If you just arrived on one of the grid's 6 primary axis, turn left
         * - If the hash of your position is greater than 127
         *          AND the current region is not full yet,
         *          If the position in front is free, place a tile forward on your right and assign it to the current region
         *          else, place a tile behind on your right and assign it to the current region
         * - If the position in front on the left is free, go to it
         *  else if the position in front is free, go to it
         *  else if the position in front on the right is free, go to it
         *  else go to the position behind on the left
         */

        private int seed;
        private int numberOfRegions, tilesPerRegion;

        public CampaignMapGenerator(int seed, int numberOfRegions, int tilesPerRegion) {
            this.seed = seed;
            this.numberOfRegions = numberOfRegions;
            this.tilesPerRegion = tilesPerRegion;
        }

        public void GenerateMap(CreateTile createTile) {
            Queue<Region> regions = new Queue<Region>();
            for (int i = 0; i < numberOfRegions; i++) {
                regions.Enqueue(new Region() {
                    Color = Color.HSVToRGB(0, 0, ((i % 8) +1) / 8f),
                    Name = "Region " + i
                });
            }
            HexMapGeneratorPen pen = new HexMapGeneratorPen(seed, tilesPerRegion, regions);
            List<GenerationOrder> orders = pen.GenerateMap();
            DualKeyDictionary<int, int, Region> grid = pen.Grid;
            int rowOffset = -pen.MinRow;
            int colOffset = -pen.MinColumn;
            int[] lastOrder = new int[]{
                orders[orders.Count-1].row,
                orders[orders.Count-1].column
            };
            DualKeyDictionary<int, int, int> distanceToEdge = CalculateDistanceToEdge(grid, lastOrder);
            Region edgeRegion = new Region() {
                Color = Color.white,
                Name = "Edge"
            };
            PerlinNoiseGenerator noiseGen = new PerlinNoiseGenerator(seed);
            foreach (GenerationOrder order in orders) {
                double noise = 0.5 * noiseGen.PerlinNoise(order.row, order.column, 0, 16, 4) + 0.5;
                int altitude = distanceToEdge[order.row][order.column];
                //altitude = (int)(altitude * noise);
                Tile t = createTile(
                    order.row + rowOffset,
                    order.column + colOffset,
                    altitude,
                    LandType.PLAIN);
                AssignTileToRegion(t, order.region);
            }
        }

        private DualKeyDictionary<int, int, int> CalculateDistanceToEdge(DualKeyDictionary<int, int, Region> grid, int[] start) {
            /* First step : find the edge.
             * Then, find all tiles adjacent to the edges and give them distance 1. They become the new edge.
             * Find all tiles adjacent to the new edge, assign them distance 2, they become the new edge, etc.
             * */
            DualKeyDictionary<int, int, int> result = new DualKeyDictionary<int, int, int>();

            EdgeWalkerPen edgePen = new EdgeWalkerPen();
            edgePen.MoveTo(start);

            DualKeyDictionary<int, int, int> edge = edgePen.GenerateEdge(grid);
            DualKeyDictionary<int, int, int> outside = new DualKeyDictionary<int, int, int>();
            DualKeyDictionary<int, int, int> inside = new DualKeyDictionary<int, int, int>();
            int distance = 0;
            while (!edge.IsEmpty) {
                edge.ForEachDo((r, c, b) => {
                    result.Add(r, c, distance);
                    int[][] neighbours = GetNeighbourCoordinates(r, c);
                    foreach (int[] neighbour in neighbours) {
                        int nR = neighbour[0];
                        int nC = neighbour[1];
                        if (grid.ContainsKeys(nR, nC) 
                            && !outside.ContainsKeys(nR, nC)
                            && !inside.ContainsKeys(nR, nC)
                            && !edge.ContainsKeys(nR, nC)
                        )
                            inside.Add(nR, nC, 0);
                    }
                });
                distance++;
                outside = edge;
                edge = inside;
                inside = new DualKeyDictionary<int, int, int>();
            }
            return result;
        }

        private int[][] GetNeighbourCoordinates(int row, int column) {
            return new int[][] {
                new int[] {row, column + 1 },
                new int[] {row, column - 1 },
                new int[] {row + 1, column },
                new int[] {row - 1, column },
                new int[] {row + 1, column + 1},
                new int[] {row - 1, column -1 },
            };
        }

        private void AssignTileToRegion(Tile tile, Region region) {
            region.Tiles.Add(tile);
            GraphicBattlefield.GetSceneTile(tile).GetComponent<Renderer>().material.color = region.Color;
        }
    }

}
